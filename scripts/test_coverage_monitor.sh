#!/bin/bash

# Test Coverage Monitor for Research Workbench
# Monitors commits every 30 seconds for test coverage and quality
# Author: [AGENT-TEST]

set -euo pipefail

WORKDIR="/Users/ladvien/research_workbench"
REVIEW_FILE="$WORKDIR/review_notes.md"
REVIEWED_COMMITS_FILE="$WORKDIR/.reviewed_commits"
LOG_FILE="$WORKDIR/scripts/test_monitor.log"

# Initialize files if they don't exist
touch "$REVIEWED_COMMITS_FILE"
touch "$LOG_FILE"

# Initialize test coverage section in review_notes.md
if ! grep -q "# Test Coverage Analysis" "$REVIEW_FILE" 2>/dev/null; then
    cat >> "$REVIEW_FILE" << 'EOF'

# Test Coverage Analysis
**Generated by [AGENT-TEST]**

This section tracks test coverage analysis, TDD compliance, and test quality across commits.

## Review Criteria
- Test coverage percentage (backend & frontend)
- TDD compliance (tests written before implementation)
- Test quality (assertions, edge cases, mocking)
- E2E test coverage
- Integration test completeness

---

EOF
fi

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

analyze_commit() {
    local commit_hash=$1
    log_message "Analyzing commit: $commit_hash"

    # Get commit details
    local commit_msg=$(git show --format="%s" -s "$commit_hash")
    local commit_date=$(git show --format="%ci" -s "$commit_hash")
    local files_changed=$(git show --name-only --format="" "$commit_hash")

    # Analysis counters
    local test_files=0
    local impl_files=0
    local has_backend_tests=0
    local has_frontend_tests=0
    local has_e2e_tests=0

    # Analyze changed files
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue

        if [[ "$file" =~ \.test\.(ts|tsx|rs)$ ]] || [[ "$file" =~ _test\.rs$ ]] || [[ "$file" =~ tests/ ]] || [[ "$file" =~ \.spec\.(ts|tsx)$ ]]; then
            ((test_files++))

            if [[ "$file" =~ backend.*\.rs$ ]] || [[ "$file" =~ tests.*\.rs$ ]]; then
                has_backend_tests=1
            elif [[ "$file" =~ frontend.*\.(ts|tsx)$ ]] || [[ "$file" =~ \.spec\.(ts|tsx)$ ]]; then
                has_frontend_tests=1
            fi

            if [[ "$file" =~ e2e/ ]] || [[ "$file" =~ \.spec\.(ts|tsx)$ ]]; then
                has_e2e_tests=1
            fi
        elif [[ "$file" =~ \.(rs|ts|tsx)$ ]] && [[ ! "$file" =~ (config|scripts)/ ]]; then
            ((impl_files++))
        fi
    done <<< "$files_changed"

    # Calculate test ratio
    local test_ratio=0
    if ((impl_files > 0)); then
        test_ratio=$((test_files * 100 / impl_files))
    fi

    # Determine TDD compliance
    local tdd_compliance="❌ Unknown"
    if [[ "$commit_msg" =~ ^test:|^feat.*test|^add.*test ]]; then
        tdd_compliance="✅ Likely TDD (test-focused commit)"
    elif ((test_files > impl_files)); then
        tdd_compliance="✅ Good (more tests than implementation)"
    elif ((test_files > 0 && impl_files > 0)); then
        tdd_compliance="⚠️ Partial (tests and implementation together)"
    elif ((test_files == 0 && impl_files > 0)); then
        tdd_compliance="❌ Poor (implementation without tests)"
    fi

    # Generate coverage analysis
    local coverage_analysis=""

    # Try to get actual coverage if possible
    local backend_coverage="N/A"
    local frontend_coverage="N/A"

    if ((has_backend_tests)); then
        if cd "$WORKDIR/backend" 2>/dev/null; then
            if command -v cargo-tarpaulin >/dev/null 2>&1; then
                backend_coverage=$(cargo tarpaulin --skip-clean --out Stdout 2>/dev/null | grep "Coverage:" | awk '{print $2}' || echo "Failed")
            fi
            cd "$WORKDIR"
        fi
    fi

    if ((has_frontend_tests)); then
        if cd "$WORKDIR/frontend" 2>/dev/null; then
            if [[ -f "package.json" ]] && command -v pnpm >/dev/null 2>&1; then
                frontend_coverage=$(pnpm test:coverage --run --reporter=json 2>/dev/null | jq -r '.coverageMap.total.lines.pct // "Failed"' 2>/dev/null || echo "Failed")
            fi
            cd "$WORKDIR"
        fi
    fi

    # Write analysis to review file
    cat >> "$REVIEW_FILE" << EOF

## Commit Analysis: \`$commit_hash\`
**Date:** $commit_date
**Message:** $commit_msg

### Test Coverage Summary
- **Implementation files changed:** $impl_files
- **Test files changed:** $test_files
- **Test-to-implementation ratio:** ${test_ratio}%
- **Backend coverage:** $backend_coverage
- **Frontend coverage:** $frontend_coverage

### Component Coverage
- **Backend tests:** $( ((has_backend_tests)) && echo "✅ Present" || echo "❌ Missing" )
- **Frontend tests:** $( ((has_frontend_tests)) && echo "✅ Present" || echo "❌ Missing" )
- **E2E tests:** $( ((has_e2e_tests)) && echo "✅ Present" || echo "❌ Missing" )

### TDD Compliance
$tdd_compliance

### Files Changed
\`\`\`
$files_changed
\`\`\`

### Quality Assessment
$( if ((test_files == 0 && impl_files > 0)); then
    echo "🔴 **CRITICAL:** Implementation changes without corresponding tests"
elif ((test_ratio < 50)); then
    echo "🟡 **WARNING:** Low test coverage ratio"
elif ((test_ratio >= 100)); then
    echo "🟢 **EXCELLENT:** Strong test coverage"
else
    echo "🔵 **GOOD:** Adequate test coverage"
fi )

---

EOF

    log_message "Analysis complete for $commit_hash"
}

check_for_new_commits() {
    log_message "Checking for new commits..."

    # Get list of recent commits
    local recent_commits=($(git log --format="%H" -n 10))

    # Check each commit
    for commit in "${recent_commits[@]}"; do
        if ! grep -q "$commit" "$REVIEWED_COMMITS_FILE"; then
            log_message "Found new commit to analyze: $commit"
            analyze_commit "$commit"
            echo "$commit" >> "$REVIEWED_COMMITS_FILE"
        fi
    done
}

initialize_monitor() {
    log_message "Initializing Test Coverage Monitor"

    # Ensure we're in the right directory
    cd "$WORKDIR"

    # Initial analysis of last 5 commits if not already reviewed
    log_message "Performing initial analysis of last 5 commits..."
    local initial_commits=("32ee9dd" "131e0e9" "6ec4c0e" "2931ece" "874ecb6")

    for commit in "${initial_commits[@]}"; do
        if ! grep -q "$commit" "$REVIEWED_COMMITS_FILE"; then
            log_message "Initial analysis of commit: $commit"
            analyze_commit "$commit"
            echo "$commit" >> "$REVIEWED_COMMITS_FILE"
        fi
    done

    log_message "Initial analysis complete"
}

main_monitor_loop() {
    log_message "Starting continuous monitoring (30-second intervals)"

    while true; do
        cd "$WORKDIR"

        # Update git refs
        git fetch --quiet origin main 2>/dev/null || true

        # Check for new commits
        check_for_new_commits

        # Wait 30 seconds
        sleep 30
    done
}

# Signal handlers for graceful shutdown
cleanup() {
    log_message "Test Coverage Monitor shutting down"
    exit 0
}

trap cleanup SIGTERM SIGINT

# Main execution
log_message "=== Test Coverage Monitor Starting ==="
initialize_monitor
main_monitor_loop